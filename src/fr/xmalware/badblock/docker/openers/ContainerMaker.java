package fr.xmalware.badblock.docker.openers;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Random;
import java.util.UUID;

import fr.badblock.api.common.utils.logs.LogType;
import fr.xmalware.badblock.docker.dockers.Docker;
import fr.xmalware.badblock.docker.dockers.LocalDocker;
import fr.xmalware.badblock.docker.instances.InstanceEntity;
import fr.xmalware.badblock.docker.instances.WorldSystem;
import fr.xmalware.badblock.docker.rabbit.RabbitLogger;
import fr.xmalware.badblock.docker.utils.ContainerUtils;

public class ContainerMaker extends Thread
{

	private InstanceEntity		instanceEntity;
	private File							containerFolder;
	private File							map;
	private String					screenName;

	public ContainerMaker(InstanceEntity instanceEntity)
	{
		super("Docker/Container/Maker/" + instanceEntity.getName() + "/" + UUID.randomUUID().toString());
		this.instanceEntity = instanceEntity;
		this.screenName = instanceEntity.getName();
		this.start();
	}
	
	@Override
	public void run()
	{
		try
		{
			RabbitLogger.sendDockerLog(LogType.INFO, "Entity " + instanceEntity.getName() + " : starting.. ");
			makeFolder();
			fillProperties();
			makeBootFile();
			makeStartFile();
			startContainer();
			RabbitLogger.sendDockerLog(LogType.INFO, "Entity " + instanceEntity.getName() + " : started!");
		}
		catch (Exception e)
		{
			e.printStackTrace();
		}
	}

	public WorldSystem getWorldSystem()
	{
		return instanceEntity.getSystem();
	}

	public void makeFolder() throws Exception
	{
		containerFolder = new File(instanceEntity.getLocalPath() + File.separatorChar);

		Runtime runtime = Runtime.getRuntime();
		ContainerUtils.deleteDirectory(containerFolder);

		try
		{
			runtime.exec("screen -X -S " + screenName + " quit").waitFor();
		}
		catch (Exception exception)
		{
		}

		containerFolder.mkdirs();

		File containerPluginFolder = new File(containerFolder, "plugins" + File.separatorChar);
		File containerLibFolder = new File(containerFolder, "lib" + File.separatorChar);
		File containerMapFolder = new File(containerFolder, getWorldSystem().getDestinationWorld() + File.separatorChar);

		// Copy default plugins
		ContainerUtils.copyFolder(PackageParts.getDefaultPluginFiles(getWorldSystem()), containerPluginFolder);
		ContainerUtils.copyFolder(PackageParts.getDefaultBaseFiles(getWorldSystem()), containerFolder);
		ContainerUtils.copyFolder(PackageParts.LIBS_FOLDER, containerLibFolder);
		ContainerUtils.copyFolder(PackageParts.getConsistentBaseFiles(getWorldSystem()), containerFolder);
		ContainerUtils.copyFolder(PackageParts.getConsistentPluginFiles(getWorldSystem()), containerPluginFolder);

		map = PackageParts.getConsistentMapFiles(getWorldSystem());
		// For random maps
		if (getWorldSystem().isRandomMap())
		{
			map = map.listFiles()[new Random().nextInt(map.listFiles().length)];
		}

		ContainerUtils.copyFolder(map, containerMapFolder);

		ContainerUtils.copyFile(PackageParts.getServerFile(getWorldSystem()), new File(containerFolder, "server.jar"));
	}

	public void fillProperties() throws Exception
	{
		File properties = new File(containerFolder, "server.properties");

		Map<String, String> newProperties = new HashMap<>();
		newProperties.put("server-name", "server-name=" + instanceEntity.getName());
		newProperties.put("max-players", "max-players=" + getWorldSystem().getSlots());
		newProperties.put("server-port", "server-port=" + instanceEntity.getPort());
		newProperties.put("server-id", "server-id=" + instanceEntity.getId());
		newProperties.put("motd", "motd=Internal Server.");
		newProperties.put("docker-started", "docker-started=" + instanceEntity.getLaunchTime());
		newProperties.put("docker-mode", "docker-mode=" + getWorldSystem().getMode());
		newProperties.put("docker-map", "docker-map=" + getWorldSystem().getDestinationWorld());
		newProperties.put("docker-gcThreads", "docker-gcThreads=" + getWorldSystem().getMode().getParallelThreads());
		newProperties.put("docker-nettyThreads", "docker-nettyThreads=" + getWorldSystem().getMode().getNettyThreads());
		newProperties.put("docker-logs", "docker-logs=" + getWorldSystem().getInstanceSystem().getName() + 
				File.separatorChar + instanceEntity.getLaunchTime() + "_" + instanceEntity.getName() + ".log");
		newProperties.put("server-ip", "server-ip=");
		newProperties.put("online-mode", "online-mode=false");
		newProperties.put("docker-prefix", "docker-prefix=" + getWorldSystem().getName());
		newProperties.put("rabbit-hostname", "rabbit-hostname=" + Docker.getInstance().getRabbit().getSettings().getHostnames()[0]);
		newProperties.put("docker-ip", "docker-ip=" + LocalDocker.getInstance().getKeepAlive().getOpen().getIp());

		if (getWorldSystem().isRandomMap())
		{
			newProperties.put("docker-fi", "docker-fi={\"_randomWorld\":\"" + map.getAbsolutePath() + "\"}");
		}
		else
		{
			newProperties.put("docker-fi", "docker-fi={}");
		}

		newProperties.put("docker-runningMatchmaking", "docker-runningMatchmaking=false");

		String fileData = "";
		List<String> lines = Files.readAllLines(Paths.get(properties.getAbsolutePath()), Charset.defaultCharset());
		for (String line : lines)
		{
			boolean edited = false;
			for (Entry<String, String> entry : newProperties.entrySet())
			{
				if (!edited)
				{
					if (line.startsWith(entry.getKey()))
					{
						edited = true;
						fileData += entry.getValue() + "\n";
					}
				}
			}

			if (!edited)
			{
				fileData += line + "\n";
			}
		}

		for (Entry<String, String> entry : newProperties.entrySet())
		{
			if (!fileData.contains(entry.getKey()))
			{
				fileData += entry.getValue() + "\n";
			}
		}
		
		properties.delete();
		
		PrintWriter writer = new PrintWriter(properties.getAbsolutePath(), "UTF-8");
		writer.print(fileData);
		writer.close();
	}

	public void makeBootFile() throws FileNotFoundException, UnsupportedEncodingException
	{
		File bootFile = new File(containerFolder, "boot.sh");
		
		String bootSh = "#!bin/bash" + System.lineSeparator();
		bootSh += "\nDIRECTORY=$(cd \"`dirname \"$0\"`\" && pwd)" + System.lineSeparator();
		bootSh += "cd \"$DIRECTORY\";" + System.lineSeparator();
		bootSh += "echo \"[Docker] Starting...\"" + System.lineSeparator();
		bootSh += "(cd \"$DIRECTORY\"; screen -dmS " + screenName + " sh start.sh )"
				+ System.lineSeparator();
		
		PrintWriter writer = new PrintWriter(bootFile.getAbsolutePath(), "UTF-8");
		writer.print(bootSh);
		writer.close();
	}
	
	public void makeStartFile() throws FileNotFoundException, UnsupportedEncodingException
	{
		File startFile = new File(containerFolder, "start.sh");
		
		String startSh = "java -Dname=" + screenName + " -Xms128M -Xmx" + getWorldSystem().getMemory() + "M -d64 -server"
				+ " -Xincgc -XX:MaxPermSize\u003d128M"
				+ " -XX\\:NewRatio\\\u003d2 -XX\\:CMSFullGCsBeforeCompaction\\\u003d1 -XX\\:SoftRefLRUPolicyMSPerMB\\\u003d2048" 
				+ " -XX\\:+CMSParallelRemarkEnabled -XX\\:+UseParNewGC -XX\\:+DisableExplicitGC -Xnoclassgc -oss4M -ss4M"
				+ " -XX\\:+UseFastAccessorMethods -XX\\:CMSInitiatingOccupancyFraction\\\u003d60 -XX\\:+UseConcMarkSweepGC"
				+ " -XX\\:UseSSE\\\u003d3 -XX\\:+UseCMSCompactAtFullCollection -XX\\:ParallelGCThreads\\=" + getWorldSystem().getMode().getParallelThreads()
				+ " -XX\\:+AggressiveOpts -cp server.jar -jar server.jar";
		
		PrintWriter writer = new PrintWriter(startFile.getAbsolutePath(), "UTF-8");
		writer.print(startSh);
		writer.close();
	}
	
	public void startContainer() throws Exception
	{
		File bootFile = new File(containerFolder, "boot.sh");
		Runtime.getRuntime().exec("bash " + bootFile.getAbsolutePath()).waitFor();
	}
	
}