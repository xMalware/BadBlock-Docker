package fr.xmalware.badblock.docker.statics;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import com.mongodb.BasicDBObject;
import com.mongodb.DB;
import com.mongodb.DBCollection;
import com.mongodb.DBObject;

import fr.badblock.api.common.minecraft.GameState;
import fr.badblock.api.common.minecraft.InstanceKeepAlive;
import fr.badblock.api.common.utils.logs.Log;
import fr.badblock.api.common.utils.logs.LogType;
import fr.xmalware.badblock.docker.dockers.Docker;
import lombok.Getter;
import lombok.Setter;

@Getter
public class StaticServer
{

	public static Map<String, List<StaticServer>> servers = new HashMap<>();

	private String						system;
	private int							id;
	private int							port;
	private boolean					portChange = true;
	private InstanceKeepAlive		keepAlive;
	private GameState					gameState;
	private int							players;
	@Setter
	private long							lastKeepAlive;
	private Map<Long, Integer>	tempIntegrations;

	public StaticServer(InstanceKeepAlive keepAlive)
	{
		this.keepAlive = keepAlive;
		this.tempIntegrations = new HashMap<>();
		this.system = keepAlive.getName().split("_")[0];

		if (keepAlive.getName().split("_").length > 1)
		{
			try
			{
				id = Integer.parseInt(keepAlive.getName().split("_")[1]);
			}
			catch (Exception err)
			{
				err.printStackTrace();
			}
		}

		keepAlive(keepAlive);
		Log.log(LogType.INFO, "Server " + keepAlive.getName() + " found.");

		if (!servers.containsKey(system))
		{
			List<StaticServer> list = new ArrayList<>();
			list.add(this);
			servers.put(system, list);
		}
		else
		{
			List<StaticServer> list = servers.get(system);
			list.add(this);
			servers.put(system, list);
		}
	}

	public void integrate(int players)
	{
		if (tempIntegrations.containsKey(System.currentTimeMillis()))
		{
			tempIntegrations.put(System.currentTimeMillis(), tempIntegrations.get(System.currentTimeMillis()) + players);
		}

		tempIntegrations.put(System.currentTimeMillis(), players);
	}

	public boolean isAvailable()
	{
		return this.keepAlive.isJoinable() && GameState.WAITING.equals(getGameState()) && this.lastKeepAlive > System.currentTimeMillis() && !isFull();
	}

	public void keepAlive(InstanceKeepAlive keepAlive)
	{
		this.keepAlive = keepAlive;
		this.gameState = keepAlive.getGameState();
		this.players = keepAlive.getPlayers();

		if (this.port != keepAlive.getPort())
		{
			this.portChange = true;
			this.port = keepAlive.getPort();
		}

		this.lastKeepAlive = System.currentTimeMillis() + 30_000L;

		if (portChange)
		{
			new Thread()
			{
				@Override
				public void run()
				{
					DB db = Docker.getInstance().getMongo().getDb();
					DBCollection dbCollection = db.getCollection("staticservers_" + Docker.getInstance().getConfig().getCluster().toUpperCase());

					DBObject dbObject = new BasicDBObject();
					dbObject.put("name", keepAlive.getName());

					DBObject dbo = new BasicDBObject();
					dbo.put("name", keepAlive.getName());
					dbo.put("ip", Docker.getInstance().getConfig().getOpen().getIp());
					dbo.put("port", keepAlive.getPort());

					if (dbCollection.count(dbObject) > 0)
					{
						dbCollection.remove(dbObject);
						try {
							Thread.sleep(5000L);
						} catch (InterruptedException e) {
							e.printStackTrace();
						}
						dbCollection.insert(dbo);
					}
					else
					{
						dbCollection.insert(dbo);
					}
				}
			}.start();
			portChange = false;
		}
	}

	public int getMarginPlayers()
	{
		int players = getPlayers();

		Iterator<Entry<Long, Integer>> iterator = tempIntegrations.entrySet().iterator();

		while (iterator.hasNext())
		{
			Entry<Long, Integer> entry = iterator.next();

			if (entry.getKey() + 3000L < System.currentTimeMillis())
			{
				continue;
			}

			players += entry.getValue();
		}

		return players;
	}

	public boolean isFull()
	{
		return getMarginPlayers() >= keepAlive.getSlots();
	}

	public boolean canHandle(int playersToDispatch)
	{
		if (!isAvailable())
		{
			return false;
		}

		return getMarginPlayers() + playersToDispatch <= keepAlive.getSlots();
	}


}
