package fr.xmalware.badblock.docker.matchmaking;

import java.util.AbstractMap.SimpleEntry;
import java.sql.Statement;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import com.mongodb.internal.connection.ConcurrentLinkedDeque;

import fr.badblock.api.common.minecraft.BungeePlayerRequest;
import fr.badblock.api.common.minecraft.BungeeRequest;
import fr.badblock.api.common.minecraft.DockerRabbitQueues;
import fr.badblock.api.common.minecraft.matchmaking.MatchmakingEnterRequest;
import fr.badblock.api.common.minecraft.party.PartyInstanceData;
import fr.badblock.api.common.tech.rabbitmq.packet.RabbitPacket;
import fr.badblock.api.common.tech.rabbitmq.packet.RabbitPacketEncoder;
import fr.badblock.api.common.tech.rabbitmq.packet.RabbitPacketMessage;
import fr.badblock.api.common.tech.rabbitmq.packet.RabbitPacketType;
import fr.badblock.api.common.utils.TimeUtils;
import fr.badblock.api.common.utils.flags.GlobalFlags;
import fr.badblock.api.common.utils.general.MathUtils;
import fr.badblock.api.common.utils.logs.LogType;
import fr.xmalware.badblock.docker.dockers.Docker;
import fr.xmalware.badblock.docker.dockers.LocalDocker;
import fr.xmalware.badblock.docker.instances.InstanceEntity;
import fr.xmalware.badblock.docker.instances.InstanceSystem;
import fr.xmalware.badblock.docker.instances.WorldSystem;
import fr.xmalware.badblock.docker.rabbit.RabbitLogger;
import fr.xmalware.badblock.docker.statics.StaticServer;
import fr.xmalware.badblock.docker.utils.BadblockDatabase;

public class MatchmakingReplier extends Thread
{

	private ConcurrentLinkedDeque<MatchmakingEnterRequest>	pendingRequests;

	private Map<String, Entry<String, Long>> time = new HashMap<>();

	public MatchmakingReplier()
	{
		super("Docker/Matchmaking/Replier");
		this.start();
	}

	@Override
	public void run()
	{
		this.pendingRequests = new ConcurrentLinkedDeque<>();
		while (true)
		{
			Iterator<MatchmakingEnterRequest> iterator = pendingRequests.iterator();

			Set<String> sPlayers = new HashSet<>();
			while (iterator.hasNext())
			{
				MatchmakingEnterRequest rq = iterator.next();
				if (sPlayers.contains(rq.getPlayerName()))
				{
					iterator.remove();
					continue;
				}

				sPlayers.add(rq.getPlayerName());
			}

			iterator = pendingRequests.iterator();

			while (iterator.hasNext())
			{
				try
				{
					MatchmakingEnterRequest request = iterator.next();

					String systemName = request.getWorldSystem();

					Collection<InstanceSystem> systems = LocalDocker.getConfig().getSystems().values();

					WorldSystem wSystem = null;
					for (InstanceSystem system : systems)
					{
						for (WorldSystem worldSystem : system.getWorlds())
						{
							if (systemName.equals(worldSystem.getName()))
							{
								wSystem = worldSystem;
							}
						}
					}

					if (wSystem == null)
					{
						iterator.remove();
					}
					else
					{
						manage(wSystem, iterator, request);
					}
				}
				catch (Exception error)
				{
					error.printStackTrace();
				}
			}

			try
			{
				Thread.sleep(100L);
			}
			catch (InterruptedException e)
			{
				e.printStackTrace();
			}
		}
	}

	public void manage(WorldSystem wSystem, Iterator<MatchmakingEnterRequest> iterator, MatchmakingEnterRequest request)
	{
		int playersToDispatch = 1 + (request.getExtraPlayers() != null ? request.getExtraPlayers().length : 0);
		List<InstanceEntity> instanceEntities = wSystem.getInstances().parallelStream()
				.filter(ent -> ent != null 
				&& !ent.isBooting() 
				&& ent.getHostId() == null 
				&& ent.isConsidered(wSystem) 
				&& ent.canHandle(wSystem, playersToDispatch))
				.collect(Collectors.toList());

		InstanceEntity selectedInstanceEntity = null;

		if (instanceEntities != null)
		{
			for (InstanceEntity instanceEntity : instanceEntities)
			{
				if (selectedInstanceEntity != null && instanceEntity.getLaunchTime() > selectedInstanceEntity.getLaunchTime())
				{
					continue;
				}

				selectedInstanceEntity = instanceEntity;
			}
		}

		boolean found = selectedInstanceEntity != null;

		StaticServer staticServer = null;

		if (!found && StaticServer.servers.containsKey(wSystem.getName()))
		{
			List<StaticServer> staticServers = StaticServer.servers.get(wSystem.getName()).parallelStream()
					.filter(ent -> ent != null &&
					ent.canHandle(playersToDispatch))
					.collect(Collectors.toList());

			if (staticServers == null)
			{
				return;
			}

			for (StaticServer st : staticServers)
			{
				if (staticServer != null && st.getId() > staticServer.getId())
				{
					continue;
				}

				staticServer = st;
			}

			found = staticServer != null;
		}

		if (!found)
		{
			String flag = "matchmaking-notfound-" + request.getPlayerName();
			if (!GlobalFlags.has(flag))
			{
				GlobalFlags.set(flag, 5000);
				double dequeuedAfter = ((double) System.currentTimeMillis() - (double) request.getTimeSent()) / 1000D;
				double shownDequeueTime = MathUtils.round(dequeuedAfter, 2);
				new BungeeRequest(
						"LOG",
						"§d[Matchmaking] §4§l(Cluster " + request.getCluster() + ") Queue: §e" + wSystem.getName() + "§4§l - §eCan't find a server for " + request.getPlayerName() + ""
								+ " after  §e" + shownDequeueTime + "§bs)"
						).send(Docker.getInstance().getRabbit());
				RabbitLogger.sendMatchmakingLog(LogType.ERROR, "[Matchmaking] Can't find a " + request.getWorldSystem() + " server for " + request.getPlayerName() + " after " + shownDequeueTime + "s (processed by " + Docker.getInstance().getIdCard().getFullId() + ").");

				new BungeePlayerRequest(
						request.getPlayerName(),
						"SEND_MESSAGE",
						System.lineSeparator() + 
						"§6[Info] §cImpossible de trouver une partie §e" + request.getWorldSystem()
						+ System.lineSeparator() + "§6[Info] §cpour le moment... §eRecherche toujours en cours..."
						+ System.lineSeparator()
						).send(Docker.getInstance().getRabbit());
				return;
			}

			return;
		}

		String instanceName = selectedInstanceEntity != null ? wSystem.getName() + "_" + selectedInstanceEntity.getId() : staticServer.getKeepAlive().getName();

		if (request.isOnline())
		{
			new Thread()
			{
				@Override
				public void run()
				{
					try
					{
						Statement statement = BadblockDatabase.getInstance().createStatement();

						statement.executeUpdate("UPDATE waitingline SET server = '" + instanceName + "', expire = '" + (System.currentTimeMillis() + 10000) + "' WHERE pseudo = '" + request.getPlayerName() + "'");
						statement.close();
					}
					catch (Exception error)
					{
						error.printStackTrace();
					}
				}
			}.start();
		}

		iterator.remove();

		if (selectedInstanceEntity != null)
		{
			selectedInstanceEntity.setPlayers(selectedInstanceEntity.getPlayers() + playersToDispatch);
		}
		else
		{
			staticServer.integrate(playersToDispatch);
		}

		if (!time.containsKey(wSystem.getName()))
		{
			time.put(wSystem
					.getName(), 
					new SimpleEntry<>(instanceName, 
							System.currentTimeMillis()));
		}
		else
		{
			Entry<String, Long> entry = time.get(wSystem.getName());

			if (!entry.getKey().equalsIgnoreCase(instanceName))
			{
				time.put(wSystem.getName(), new SimpleEntry<>(instanceName, System.currentTimeMillis()));
			}
			else
			{
				long diff = System.currentTimeMillis() - time.get(wSystem.getName()).getValue();

				if (diff > 30_000L)
				{
					RabbitPacketMessage rabbitPacketMessage = new RabbitPacketMessage(5000, wSystem.getName() + ";" + instanceName);
					RabbitPacket rabbitPacket = new RabbitPacket(rabbitPacketMessage,
							"hurryup", true, RabbitPacketEncoder.UTF8, RabbitPacketType.PUBLISHER);
					Docker.getInstance().getRabbit().sendPacket(rabbitPacket);
				}
			}
		}

		double dequeuedAfter = ((double) System.currentTimeMillis() - (double) request.getTimeSent()) / 1000D;
		double shownDequeueTime = MathUtils.round(dequeuedAfter, 2);

		new BungeeRequest(
				"LOG",
				"§d[Matchmaking] §b(Cluster " + request.getCluster() + ") Queue: §e" + wSystem.getName() + "§b - §e" + 
						request.getPlayerName() + "§b sent to §e" + instanceName + "§b (dequeued after §e" + shownDequeueTime + "§bs)"
				).send(Docker.getInstance().getRabbit());

		RabbitLogger.sendMatchmakingLog(LogType.SUCCESS, "[Matchmaking] Request handled. Queue: " + request.getWorldSystem() + " for " + request.getPlayerName() + " => sent to " + instanceName + " (processed by " + Docker.getInstance().getIdCard().getFullId() + ").");

		new BungeePlayerRequest(
				request.getPlayerName(),
				"SEND_SERVER",
				instanceName + "|" + "MATCHMAKING"
				).send(Docker.getInstance().getRabbit());

		if (request.getExtraPlayers() != null)
		{
			for (String extraPlayer : request.getExtraPlayers())
			{
				new BungeeRequest(
						"LOG",
						"§d[Matchmaking] §b(Cluster " + request.getCluster() + ") Queue: §e" + wSystem.getName() + "§b - §e" + 
								extraPlayer + "§b sent to §e" + instanceName + "§b along with §e" + request.getPlayerName() + " §b(dequeued after §e" + shownDequeueTime + "§bs)"
						).send(Docker.getInstance().getRabbit());

				RabbitLogger.sendMatchmakingLog(LogType.SUCCESS, "[Matchmaking] Request handled. Queue: " + request.getWorldSystem()
				+ " for " + extraPlayer + " along with " + request.getPlayerName() + " => sent to " + instanceName + " (processed by " + Docker.getInstance().getIdCard().getFullId() + ").");

				new BungeePlayerRequest(
						extraPlayer,
						"SEND_SERVER",
						instanceName + "|" + "MATCHMAKING"
						).send(Docker.getInstance().getRabbit());
			}

			if (request.getExtraPlayers().length > 0)
			{
				new Thread("Docker/Matchmaking/Replier/PartySender-" + UUID.randomUUID())
				{
					@Override
					public void run()
					{
						TimeUtils.sleep(1500);
						PartyInstanceData data = new PartyInstanceData(instanceName, request.getPlayerName(), request.getExtraPlayers());

						RabbitPacketMessage rabbitPacketMessage = new RabbitPacketMessage(5000, Docker.getInstance().getGson().toJson(data));
						RabbitPacket rabbitPacket = new RabbitPacket(rabbitPacketMessage,
								DockerRabbitQueues.INSTANCE_PARTY_DATA.getQueue(), true, RabbitPacketEncoder.UTF8, RabbitPacketType.PUBLISHER);
						Docker.getInstance().getRabbit().sendPacket(rabbitPacket);
					}
				}.start();
			}
		}
	}

	public void push(MatchmakingEnterRequest request)
	{
		try
		{
			assert this.isAlive();
			new Thread("matchmaking/manage-" + UUID.randomUUID().toString())
			{
				@Override
				public void run()
				{
					Iterator<MatchmakingEnterRequest> iterator = pendingRequests.iterator();

					while (iterator.hasNext())
					{
						MatchmakingEnterRequest rq = iterator.next();
						if (rq.getPlayerName().contains(request.getPlayerName()))
						{
							if (rq.getWorldSystem().equalsIgnoreCase(request.getWorldSystem()))
							{
								new BungeePlayerRequest(
										request.getPlayerName(),
										"SEND_MESSAGE",
										"§6[Info] §cTa demande a déjà été prise en compte."
										).send(Docker.getInstance().getRabbit());
							}
							
							iterator.remove();
							return;
						}
					}

					Collection<InstanceSystem> systems = LocalDocker.getConfig().getSystems().values();
					WorldSystem wSystem = null;
					for (InstanceSystem system : systems)
					{
						for (WorldSystem worldSystem : system.getWorlds())
						{
							if (request.getWorldSystem().equals(worldSystem.getName()))
							{
								wSystem = worldSystem;
							}
						}
					}

					if (wSystem == null)
					{
						new BungeePlayerRequest(
								request.getPlayerName(),
								"SEND_MESSAGE",
								"§6[Info] §cCe jeu n'existe plus. Veuillez réessayer plus tard."
								).send(Docker.getInstance().getRabbit());
						return;
					}

					int requestPlayers = 1 + (request.getExtraPlayers() != null ? request.getExtraPlayers().length : 0);
					if (wSystem.getSlots() < requestPlayers)
					{
						new BungeePlayerRequest(
								request.getPlayerName(),
								"SEND_MESSAGE",
								"§c[Erreur] Le jeu §b" + wSystem.getName() + " §cne peut supporter que"
										+ " §e" + wSystem.getSlots() + " §cjoueurs." + System.lineSeparator() + 
										"§c[Erreur] Il y a actuellement §e" + requestPlayers + " §cjoueurs dans votre groupe.")
						.send(Docker.getInstance().getRabbit());
						return;
					}

					String gr = requestPlayers > 1 ? "§egroupé avec §b" + requestPlayers + " §ejoueurs" : "§esans groupe";

					try
					{
						new BungeePlayerRequest(
								request.getPlayerName(),
								"SEND_MESSAGE",
								" " + System.lineSeparator() +
								"§6[Info] Recherche d'une partie pour le jeu §e" + request.getWorldSystem() + "§6..."
								+ System.lineSeparator() +
								"§6[Info] Détails de votre demande : " + gr + System.lineSeparator() + " ").send(Docker.getInstance().getRabbit());

						new BungeeRequest(
								"LOG",
								"§d[Matchmaking] §b(Cluster " + request.getCluster() + ") Queue: §e" + request.getWorldSystem() + "§b - §e" + 
										request.getPlayerName() + "§b added in queue."
								).send(Docker.getInstance().getRabbit());
						RabbitLogger.sendMatchmakingLog(LogType.INFO, "[Matchmaking] Request received. Queue: " + request.getWorldSystem() + " for " + request.getPlayerName() + ". Looking for a server (processing by " + Docker.getInstance().getIdCard().getFullId() + ").");

						if (request.getExtraPlayers() != null)
						{
							for (String extraPlayer : request.getExtraPlayers())
							{
								new BungeePlayerRequest(
										extraPlayer,
										"SEND_MESSAGE",
										System.lineSeparator() + 
										"§6[Info] Le chef de votre groupe §e" + request.getPlayerName() + " §6a lancé une partie de §e" + request.getWorldSystem() + "§6..."
										+ System.lineSeparator() +
										"§6[Info] Détails de la demande : " + gr
										+ "§6[Info] Vous allez être téléporté avec le groupe."
										+ System.lineSeparator()
										).send(Docker.getInstance().getRabbit());

								new BungeeRequest(
										"LOG",
										"§d[Matchmaking] §b(Cluster " + request.getCluster() + ") Queue: §e" + request.getWorldSystem() + "§b - §e" + 
												extraPlayer + "§b added in queue along with " + request.getPlayerName() + "."
										).send(Docker.getInstance().getRabbit());
								RabbitLogger.sendMatchmakingLog(LogType.INFO, "[Matchmaking] Request received. Queue: " + request.getWorldSystem() + " for " + extraPlayer + " along with " + request.getPlayerName() + ". Looking for a server (processing by " + Docker.getInstance().getIdCard().getFullId() + ").");
							}
						}

						pendingRequests.add(request);
					}
					catch (Exception error)
					{
						new BungeePlayerRequest(
								request.getPlayerName(),
								"SEND_MESSAGE",
								"§6[Info] §cUne erreur est survenue lors de votre ajout en file d'attente pour le jeu " + request.getWorldSystem() + "."
								).send(Docker.getInstance().getRabbit());
					}
				}
			}.start();
		}	catch (Exception error)
		{
			new BungeePlayerRequest(
					request.getPlayerName(),
					"SEND_MESSAGE",
					"§6[Info] §cUne erreur est survenue lors de votre ajout en file d'attente pour le jeu " + request.getWorldSystem() + "."
					).send(Docker.getInstance().getRabbit());
		}
	}

}