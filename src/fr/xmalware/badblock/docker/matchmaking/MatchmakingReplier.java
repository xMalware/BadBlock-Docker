package fr.xmalware.badblock.docker.matchmaking;

import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import com.mongodb.internal.connection.ConcurrentLinkedDeque;

import fr.badblock.api.common.minecraft.BungeePlayerRequest;
import fr.badblock.api.common.minecraft.BungeeRequest;
import fr.badblock.api.common.minecraft.DockerRabbitQueues;
import fr.badblock.api.common.minecraft.matchmaking.MatchmakingEnterRequest;
import fr.badblock.api.common.minecraft.party.PartyInstanceData;
import fr.badblock.api.common.tech.rabbitmq.packet.RabbitPacket;
import fr.badblock.api.common.tech.rabbitmq.packet.RabbitPacketEncoder;
import fr.badblock.api.common.tech.rabbitmq.packet.RabbitPacketMessage;
import fr.badblock.api.common.tech.rabbitmq.packet.RabbitPacketType;
import fr.badblock.api.common.utils.TimeUtils;
import fr.badblock.api.common.utils.flags.GlobalFlags;
import fr.badblock.api.common.utils.general.MathUtils;
import fr.badblock.api.common.utils.logs.LogType;
import fr.xmalware.badblock.docker.dockers.Docker;
import fr.xmalware.badblock.docker.dockers.LocalDocker;
import fr.xmalware.badblock.docker.instances.InstanceEntity;
import fr.xmalware.badblock.docker.instances.InstanceSystem;
import fr.xmalware.badblock.docker.instances.WorldSystem;
import fr.xmalware.badblock.docker.rabbit.RabbitLogger;

public class MatchmakingReplier extends Thread
{

	private ConcurrentLinkedDeque<MatchmakingEnterRequest>	pendingRequests;

	public MatchmakingReplier()
	{
		super("Docker/Matchmaking/Replier");
		this.start();
	}

	@Override
	public void run()
	{
		this.pendingRequests = new ConcurrentLinkedDeque<>();
		while (true)
		{
			Iterator<MatchmakingEnterRequest> iterator = pendingRequests.iterator();

			Set<String> sPlayers = new HashSet<>();
			while (iterator.hasNext())
			{
				MatchmakingEnterRequest rq = iterator.next();
				if (sPlayers.contains(rq.getPlayerName()))
				{
					iterator.remove();
					continue;
				}

				sPlayers.add(rq.getPlayerName());
			}

			iterator = pendingRequests.iterator();

			while (iterator.hasNext())
			{
				try
				{
					MatchmakingEnterRequest request = iterator.next();

					String systemName = request.getWorldSystem();

					Collection<InstanceSystem> systems = LocalDocker.getConfig().getSystems().values();

					WorldSystem wSystem = null;
					for (InstanceSystem system : systems)
					{
						for (WorldSystem worldSystem : system.getWorlds())
						{
							if (systemName.equals(worldSystem.getName()))
							{
								wSystem = worldSystem;
							}
						}
					}

					if (wSystem == null)
					{
						iterator.remove();
					}
					else
					{
						manage(wSystem, iterator, request);
					}
				}
				catch (Exception error)
				{
					error.printStackTrace();
				}
			}

			try
			{
				Thread.sleep(100L);
			}
			catch (InterruptedException e)
			{
				e.printStackTrace();
			}
		}
	}

	public void manage(WorldSystem wSystem, Iterator<MatchmakingEnterRequest> iterator, MatchmakingEnterRequest request)
	{
		int playersToDispatch = 1 + (request.getExtraPlayers() != null ? request.getExtraPlayers().length : 0);
		List<InstanceEntity> instanceEntities = wSystem.getInstances().parallelStream()
				.filter(ent -> !ent.isBooting() && ent.getHostId() == null && ent.isConsidered(wSystem) && ent.canHandle(wSystem, playersToDispatch))
				.collect(Collectors.toList());

		if (instanceEntities == null)
		{
			return;
		}

		InstanceEntity selectedInstanceEntity = null;

		for (InstanceEntity instanceEntity : instanceEntities)
		{
			if (selectedInstanceEntity != null && instanceEntity.getLaunchTime() > selectedInstanceEntity.getLaunchTime())
			{
				continue;
			}

			selectedInstanceEntity = instanceEntity;
		}

		if (selectedInstanceEntity == null)
		{
			double dequeuedAfter = ((double) System.currentTimeMillis() - (double) request.getTimeSent()) / 1000D;
			double shownDequeueTime = MathUtils.round(dequeuedAfter, 2);
			new BungeeRequest(
					"LOG",
					"§d[Matchmaking] §4§l(Cluster " + request.getCluster() + ") Queue: §e" + wSystem.getName() + "§4§l - §eCan't find a server for " + request.getPlayerName() + ""
							+ " after  §e" + shownDequeueTime + "§bs)"
					).send(Docker.getInstance().getRabbit());
			RabbitLogger.sendMatchmakingLog(LogType.ERROR, "[Matchmaking] Can't find a " + request.getWorldSystem() + " server for " + request.getPlayerName() + " after " + shownDequeueTime + "s (processed by " + Docker.getInstance().getIdCard().getFullId() + ").");



			String flag = "matchmaking-notfound-" + request.getPlayerName();
			if (!GlobalFlags.has(flag))
			{
				new BungeePlayerRequest(
						request.getPlayerName(),
						"SEND_MESSAGE",
						System.lineSeparator() + 
						"§6[Info] §cImpossible de trouver une partie §e" + request.getWorldSystem()
						+ System.lineSeparator() + "§6[Info] §cpour le moment... §eRecherche toujours en cours..."
						+ System.lineSeparator()
						).send(Docker.getInstance().getRabbit());
				return;
			}

			GlobalFlags.set(flag, 5000);

			return;
		}

		iterator.remove();
		selectedInstanceEntity.setPlayers(selectedInstanceEntity.getPlayers() + playersToDispatch);

		double dequeuedAfter = ((double) System.currentTimeMillis() - (double) request.getTimeSent()) / 1000D;
		double shownDequeueTime = MathUtils.round(dequeuedAfter, 2);

		String instanceName = wSystem.getName() + "_" + selectedInstanceEntity.getId();

		new BungeeRequest(
				"LOG",
				"§d[Matchmaking] §b(Cluster " + request.getCluster() + ") Queue: §e" + wSystem.getName() + "§b - §e" + 
						request.getPlayerName() + "§b sent to §e" + instanceName + "§b (dequeued after §e" + shownDequeueTime + "§bs)"
				).send(Docker.getInstance().getRabbit());

		RabbitLogger.sendMatchmakingLog(LogType.SUCCESS, "[Matchmaking] Request handled. Queue: " + request.getWorldSystem() + " for " + request.getPlayerName() + " => sent to " + instanceName + " (processed by " + Docker.getInstance().getIdCard().getFullId() + ").");

		new BungeePlayerRequest(
				request.getPlayerName(),
				"SEND_SERVER",
				instanceName + "|" + "MATCHMAKING"
				).send(Docker.getInstance().getRabbit());

		if (request.getExtraPlayers() != null)
		{
			for (String extraPlayer : request.getExtraPlayers())
			{
				new BungeeRequest(
						"LOG",
						"§d[Matchmaking] §b(Cluster " + request.getCluster() + ") Queue: §e" + wSystem.getName() + "§b - §e" + 
								extraPlayer + "§b sent to §e" + instanceName + "§b along with §e" + request.getPlayerName() + " §b(dequeued after §e" + shownDequeueTime + "§bs)"
						).send(Docker.getInstance().getRabbit());

				RabbitLogger.sendMatchmakingLog(LogType.SUCCESS, "[Matchmaking] Request handled. Queue: " + request.getWorldSystem()
				+ " for " + extraPlayer + " along with " + request.getPlayerName() + " => sent to " + instanceName + " (processed by " + Docker.getInstance().getIdCard().getFullId() + ").");

				new BungeePlayerRequest(
						extraPlayer,
						"SEND_SERVER",
						instanceName + "|" + "MATCHMAKING"
						).send(Docker.getInstance().getRabbit());
			}

			if (request.getExtraPlayers().length > 0)
			{
				new Thread("Docker/Matchmaking/Replier/PartySender-" + UUID.randomUUID())
				{
					@Override
					public void run()
					{
						TimeUtils.sleep(1500);
						PartyInstanceData data = new PartyInstanceData(instanceName, request.getPlayerName(), request.getExtraPlayers());

						RabbitPacketMessage rabbitPacketMessage = new RabbitPacketMessage(5000, Docker.getInstance().getGson().toJson(data));
						RabbitPacket rabbitPacket = new RabbitPacket(rabbitPacketMessage,
								DockerRabbitQueues.INSTANCE_PARTY_DATA.getQueue(), true, RabbitPacketEncoder.UTF8, RabbitPacketType.PUBLISHER);
						Docker.getInstance().getRabbit().sendPacket(rabbitPacket);
					}
				}.start();
			}
		}
	}

	public void push(MatchmakingEnterRequest request)
	{
		try
		{
			assert this.isAlive();
			new Thread("matchmaking/manage-" + UUID.randomUUID().toString())
			{
				@Override
				public void run()
				{
					Iterator<MatchmakingEnterRequest> iterator = pendingRequests.iterator();

					Set<String> sPlayers = new HashSet<>();
					while (iterator.hasNext())
					{
						MatchmakingEnterRequest rq = iterator.next();
						if (sPlayers.contains(rq.getPlayerName()))
						{
							new BungeePlayerRequest(
									request.getPlayerName(),
									"SEND_MESSAGE",
									"§6[Info] §cTa demande a déjà été prise en compte."
									).send(Docker.getInstance().getRabbit());
							return;
						}
					}

					Collection<InstanceSystem> systems = LocalDocker.getConfig().getSystems().values();
					WorldSystem wSystem = null;
					for (InstanceSystem system : systems)
					{
						for (WorldSystem worldSystem : system.getWorlds())
						{
							if (request.getWorldSystem().equals(worldSystem.getName()))
							{
								wSystem = worldSystem;
							}
						}
					}

					if (wSystem == null)
					{
						new BungeePlayerRequest(
								request.getPlayerName(),
								"SEND_MESSAGE",
								"§6[Info] §cCe jeu n'existe plus. Veuillez réessayer plus tard."
								).send(Docker.getInstance().getRabbit());
						return;
					}

					int requestPlayers = 1 + (request.getExtraPlayers() != null ? request.getExtraPlayers().length : 0);
					if (wSystem.getSlots() < requestPlayers)
					{
						new BungeePlayerRequest(
								request.getPlayerName(),
								"SEND_MESSAGE",
								"§c[Erreur] Le jeu §b" + wSystem.getName() + " §cne peut supporter que"
										+ " §e" + wSystem.getSlots() + " §cjoueurs." + System.lineSeparator() + 
										"§c[Erreur] Il y a actuellement §e" + requestPlayers + " §cjoueurs dans votre groupe.")
						.send(Docker.getInstance().getRabbit());
						return;
					}

					String gr = requestPlayers > 1 ? "§egroupé avec §b" + requestPlayers + " §ejoueurs" : "§esans groupe";

					try
					{
						new BungeePlayerRequest(
								request.getPlayerName(),
								"SEND_MESSAGE",
								" " + System.lineSeparator() +
								"§6[Info] Recherche d'une partie pour le jeu §e" + request.getWorldSystem() + "§6..."
								+ System.lineSeparator() +
								"§6[Info] Détails de votre demande : " + gr + System.lineSeparator() + " ").send(Docker.getInstance().getRabbit());

						new BungeeRequest(
								"LOG",
								"§d[Matchmaking] §b(Cluster " + request.getCluster() + ") Queue: §e" + request.getWorldSystem() + "§b - §e" + 
										request.getPlayerName() + "§b added in queue."
								).send(Docker.getInstance().getRabbit());
						RabbitLogger.sendMatchmakingLog(LogType.INFO, "[Matchmaking] Request received. Queue: " + request.getWorldSystem() + " for " + request.getPlayerName() + ". Looking for a server (processing by " + Docker.getInstance().getIdCard().getFullId() + ").");

						if (request.getExtraPlayers() != null)
						{
							for (String extraPlayer : request.getExtraPlayers())
							{

								new BungeePlayerRequest(
										extraPlayer,
										"SEND_MESSAGE",
										System.lineSeparator() + 
										"§6[Info] Le chef de votre groupe §e" + request.getPlayerName() + " §6a lancé une partie de §e" + request.getWorldSystem() + "§6..."
										+ System.lineSeparator() +
										"§6[Info] Détails de la demande : " + gr
										+ "§6[Info] Vous allez être téléporté avec le groupe."
										+ System.lineSeparator()
										).send(Docker.getInstance().getRabbit());
								new BungeeRequest(
										"LOG",
										"§d[Matchmaking] §b(Cluster " + request.getCluster() + ") Queue: §e" + request.getWorldSystem() + "§b - §e" + 
												extraPlayer + "§b added in queue along with " + request.getPlayerName() + "."
										).send(Docker.getInstance().getRabbit());
								RabbitLogger.sendMatchmakingLog(LogType.INFO, "[Matchmaking] Request received. Queue: " + request.getWorldSystem() + " for " + extraPlayer + " along with " + request.getPlayerName() + ". Looking for a server (processing by " + Docker.getInstance().getIdCard().getFullId() + ").");
							}
						}

						pendingRequests.add(request);
					}
					catch (Exception error)
					{
						new BungeePlayerRequest(
								request.getPlayerName(),
								"SEND_MESSAGE",
								"§6[Info] §cUne erreur est survenue lors de votre ajout en file d'attente pour le jeu " + request.getWorldSystem() + "."
								).send(Docker.getInstance().getRabbit());
					}
				}
			}.start();
		}	catch (Exception error)
		{
			new BungeePlayerRequest(
					request.getPlayerName(),
					"SEND_MESSAGE",
					"§6[Info] §cUne erreur est survenue lors de votre ajout en file d'attente pour le jeu " + request.getWorldSystem() + "."
					).send(Docker.getInstance().getRabbit());
		}
	}

}