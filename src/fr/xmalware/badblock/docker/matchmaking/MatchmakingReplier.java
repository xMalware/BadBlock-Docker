package fr.xmalware.badblock.docker.matchmaking;

import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import com.mongodb.internal.connection.ConcurrentLinkedDeque;

import fr.badblock.api.common.minecraft.BungeePlayerRequest;
import fr.badblock.api.common.minecraft.BungeeRequest;
import fr.badblock.api.common.minecraft.matchmaking.MatchmakingEnterRequest;
import fr.badblock.api.common.utils.general.MathUtils;
import fr.badblock.api.common.utils.logs.LogType;
import fr.xmalware.badblock.docker.dockers.Docker;
import fr.xmalware.badblock.docker.dockers.LocalDocker;
import fr.xmalware.badblock.docker.instances.InstanceEntity;
import fr.xmalware.badblock.docker.instances.InstanceSystem;
import fr.xmalware.badblock.docker.instances.WorldSystem;
import fr.xmalware.badblock.docker.rabbit.RabbitLogger;

public class MatchmakingReplier extends Thread
{

	private ConcurrentLinkedDeque<MatchmakingEnterRequest>	pendingRequests;

	public MatchmakingReplier()
	{
		super("Docker/Matchmaking/Replier");
		this.start();
	}

	@Override
	public void run()
	{
		this.pendingRequests = new ConcurrentLinkedDeque<>();
		while (true)
		{
			Iterator<MatchmakingEnterRequest> iterator = pendingRequests.iterator();

			Set<String> sPlayers = new HashSet<>();
			while (iterator.hasNext())
			{
				MatchmakingEnterRequest rq = iterator.next();
				if (sPlayers.contains(rq.getPlayerName()))
				{
					iterator.remove();
					continue;
				}

				sPlayers.add(rq.getPlayerName());
			}
			
			iterator = pendingRequests.iterator();

			while (iterator.hasNext())
			{
				try
				{
					MatchmakingEnterRequest request = iterator.next();

					String systemName = request.getWorldSystem();

					Collection<InstanceSystem> systems = LocalDocker.getConfig().getSystems().values();

					WorldSystem wSystem = null;
					for (InstanceSystem system : systems)
					{
						for (WorldSystem worldSystem : system.getWorlds())
						{
							if (systemName.equals(worldSystem.getName()))
							{
								wSystem = worldSystem;
							}
						}
					}

					if (wSystem == null)
					{
						iterator.remove();
					}
					else
					{
						manage(wSystem, iterator, request);
					}
				}
				catch (Exception error)
				{
					error.printStackTrace();
				}
			}

			try
			{
				Thread.sleep(1000L);
			}
			catch (InterruptedException e)
			{
				e.printStackTrace();
			}
		}
	}

	public void manage(WorldSystem wSystem, Iterator<MatchmakingEnterRequest> iterator, MatchmakingEnterRequest request)
	{
		int playersToDispatch = 1 + (request.getExtraPlayers() != null ? request.getExtraPlayers().length : 0);
		List<InstanceEntity> instanceEntities = wSystem.getInstances().parallelStream()
				.filter(ent -> !ent.isBooting() && ent.isConsidered(wSystem) && ent.canHandle(wSystem, playersToDispatch))
				.collect(Collectors.toList());

		if (instanceEntities == null)
		{
			return;
		}

		InstanceEntity selectedInstanceEntity = null;

		for (InstanceEntity instanceEntity : instanceEntities)
		{
			if (selectedInstanceEntity != null && instanceEntity.getId() > selectedInstanceEntity.getId())
			{
				continue;
			}

			selectedInstanceEntity = instanceEntity;
		}

		if (selectedInstanceEntity == null)
		{
			return;
		}

		iterator.remove();

		double dequeuedAfter = ((double) System.currentTimeMillis() - (double) request.getTimeSent()) / 1000D;
		double shownDequeueTime = MathUtils.round(dequeuedAfter, 2);

		String instanceName = wSystem.getName() + "_" + selectedInstanceEntity.getId();

		new BungeeRequest(
				"LOG",
				"§d[Matchmaking] §b(Cluster " + request.getCluster() + ") Queue: §e" + wSystem.getName() + "§b - §e" + 
						request.getPlayerName() + "§b sent to §e" + instanceName + "§b (dequeued after §e" + shownDequeueTime + "§bs)"
				).send(Docker.getInstance().getRabbit());

		RabbitLogger.sendMatchmakingLog(LogType.SUCCESS, "[Matchmaking] Request handled. Queue: " + request.getWorldSystem() + " for " + request.getPlayerName() + " => sent to " + instanceName + " (processed by " + Docker.getInstance().getIdCard().getFullId() + ").");

		new BungeePlayerRequest(
				request.getPlayerName(),
				"SEND_SERVER",
				instanceName + "|" + "MATCHMAKING"
				).send(Docker.getInstance().getRabbit());

		if (request.getExtraPlayers() != null)
		{
			for (String extraPlayer : request.getExtraPlayers())
			{
				new BungeeRequest(
						"LOG",
						"§d[Matchmaking] §b(Cluster " + request.getCluster() + ") Queue: §e" + wSystem.getName() + "§b - §e" + 
								extraPlayer + "§b sent to §e" + instanceName + "§b along with §e" + request.getPlayerName() + " §b(dequeued after §e" + shownDequeueTime + "§bs)"
						).send(Docker.getInstance().getRabbit());

				RabbitLogger.sendMatchmakingLog(LogType.SUCCESS, "[Matchmaking] Request handled. Queue: " + request.getWorldSystem()
				+ " for " + extraPlayer + " along with " + request.getPlayerName() + " => sent to " + instanceName + " (processed by " + Docker.getInstance().getIdCard().getFullId() + ").");

				new BungeePlayerRequest(
						extraPlayer,
						"SEND_SERVER",
						instanceName + "|" + "MATCHMAKING"
						).send(Docker.getInstance().getRabbit());
			}
		}
	}

	public void push(MatchmakingEnterRequest request)
	{
		try
		{
			assert this.isAlive();
			new Thread("matchmaking/manage-" + UUID.randomUUID().toString())
			{
				@Override
				public void run()
				{
					try
					{
						new BungeePlayerRequest(
								request.getPlayerName(),
								"SEND_MESSAGE",
								"§6[Info] Vous avez été ajouté à la file d'attente pour le jeu " + request.getWorldSystem() + "." + System.lineSeparator() + ""
										+ "§6[Info] §aVous allez être téléporté.."
								).send(Docker.getInstance().getRabbit());

						new BungeeRequest(
								"LOG",
								"§d[Matchmaking] §b(Cluster " + request.getCluster() + ") Queue: §e" + request.getWorldSystem() + "§b - §e" + 
										request.getPlayerName() + "§b added in queue."
								).send(Docker.getInstance().getRabbit());
						RabbitLogger.sendMatchmakingLog(LogType.INFO, "[Matchmaking] Request received. Queue: " + request.getWorldSystem() + " for " + request.getPlayerName() + ". Looking for a server (processing by " + Docker.getInstance().getIdCard().getFullId() + ").");

						if (request.getExtraPlayers() != null)
						{
							for (String extraPlayer : request.getExtraPlayers())
							{
								new BungeeRequest(
										"LOG",
										"§d[Matchmaking] §b(Cluster " + request.getCluster() + ") Queue: §e" + request.getWorldSystem() + "§b - §e" + 
												extraPlayer + "§b added in queue along with " + request.getPlayerName() + "."
										).send(Docker.getInstance().getRabbit());
								RabbitLogger.sendMatchmakingLog(LogType.INFO, "[Matchmaking] Request received. Queue: " + request.getWorldSystem() + " for " + extraPlayer + " along with " + request.getPlayerName() + ". Looking for a server (processing by " + Docker.getInstance().getIdCard().getFullId() + ").");
							}
						}

						pendingRequests.add(request);
					}
					catch (Exception error)
					{
						new BungeePlayerRequest(
								request.getPlayerName(),
								"SEND_MESSAGE",
								"§6[Info] §cUne erreur est survenue lors de votre ajout en file d'attente pour le jeu " + request.getWorldSystem() + "."
								).send(Docker.getInstance().getRabbit());
					}
				}
			}.start();
		}	catch (Exception error)
		{
			new BungeePlayerRequest(
					request.getPlayerName(),
					"SEND_MESSAGE",
					"§6[Info] §cUne erreur est survenue lors de votre ajout en file d'attente pour le jeu " + request.getWorldSystem() + "."
					).send(Docker.getInstance().getRabbit());
		}
	}

}