package fr.xmalware.badblock.docker.dockers;

import java.util.HashMap;
import java.util.List;
import java.util.Map.Entry;
import java.util.TimerTask;

import fr.badblock.api.common.minecraft.DockerRabbitQueues;
import fr.badblock.api.common.minecraft.matchmaking.MatchmakingQueues;
import fr.badblock.api.common.tech.rabbitmq.RabbitService;
import fr.badblock.api.common.tech.rabbitmq.listener.RabbitListenerType;
import fr.badblock.api.common.tech.rabbitmq.packet.RabbitPacket;
import fr.badblock.api.common.tech.rabbitmq.packet.RabbitPacketEncoder;
import fr.badblock.api.common.tech.rabbitmq.packet.RabbitPacketMessage;
import fr.badblock.api.common.tech.rabbitmq.packet.RabbitPacketType;
import fr.badblock.api.common.utils.data.Callback;
import fr.badblock.api.common.utils.logs.LogType;
import fr.xmalware.badblock.docker.config.InstanceConfiguration;
import fr.xmalware.badblock.docker.instances.InstanceEntity;
import fr.xmalware.badblock.docker.instances.InstanceInfoCache;
import fr.xmalware.badblock.docker.instances.InstanceSystem;
import fr.xmalware.badblock.docker.instances.WorldSystem;
import fr.xmalware.badblock.docker.matchmaking.MatchmakingReplier;
import fr.xmalware.badblock.docker.rabbit.RabbitLogger;
import fr.xmalware.badblock.docker.rabbit.listeners.InstanceKeepAliveListener;
import fr.xmalware.badblock.docker.rabbit.listeners.InstanceLocalOpenListener;
import fr.xmalware.badblock.docker.rabbit.listeners.InstanceOpenListener;
import fr.xmalware.badblock.docker.rabbit.listeners.InstanceStopListener;
import fr.xmalware.badblock.docker.rabbit.listeners.MatchmakingEnterRequestListener;
import fr.xmalware.badblock.docker.rabbit.listeners.PackageDataReceiverListener;
import fr.xmalware.badblock.docker.rabbit.listeners.PackageUpdateRequestListener;
import fr.xmalware.badblock.docker.rabbit.objects.KeepAlive;
import lombok.Getter;

@Getter
public class LocalDocker
{

	@Getter private static InstanceConfiguration	config;

	@Getter private static LocalDocker				instance;

	private KeepAlive												keepAlive;
	private TimerTask												keepAliveTask;

	private LocalDockerData									data = new LocalDockerData();
	private MatchmakingReplier							matchmaking;

	public LocalDocker() throws Exception
	{
		instance = this;

		config = new InstanceConfiguration();

		config.callback = new Callback<Boolean>()
		{

			@Override
			public void done(Boolean result, Throwable error)
			{
				try {
					fillCache();
				} catch (Exception e) {
					e.printStackTrace();
				}

				for (InstanceSystem instanceSystem : LocalDocker.getConfig().getSystems().values())
				{
					for (WorldSystem worldSystem : instanceSystem.getWorlds())
					{
						for (InstanceEntity instanceEntity : worldSystem.getInstances())
						{
							RabbitLogger.sendDockerLog(LogType.INFO, "Detected local instance: " + instanceEntity.getName());
						}
					}
				}

				LocalDocker.getInstance().keepAlive(Docker.getInstance());

				Docker docker = Docker.getInstance();

				prepareClose();

				keepAlive(docker);

				keepAliveTask = new TimerTask()
				{
					@Override
					public void run()
					{
						keepAlive(docker);
					}
				};
				docker.getTimer().schedule(keepAliveTask, 1000, 1000);

				new LocalDockerDataOverseer();
				new LocalDockerScreenOverseer();
				new LocalDockerWorker();

				// instance net
				RabbitService rabbit = Docker.getInstance().getRabbit();
				rabbit.addListener(new InstanceKeepAliveListener(rabbit, DockerRabbitQueues.INSTANCE_KEEPALIVE.getQueue(), RabbitListenerType.SUBSCRIBER, false));
				rabbit.addListener(new InstanceStopListener(rabbit, DockerRabbitQueues.INSTANCE_STOP.getQueue(), RabbitListenerType.SUBSCRIBER, true));
				rabbit.addListener(new InstanceOpenListener(rabbit, DockerRabbitQueues.INSTANCE_OPEN.getQueue() + "_" + docker.getIdCard().getCluster(), RabbitListenerType.MESSAGE_BROKER, false));
				rabbit.addListener(new InstanceLocalOpenListener(rabbit, DockerRabbitQueues.INSTANCE_OPEN.getQueue() + "_" + docker.getIdCard().getFullId(), RabbitListenerType.MESSAGE_BROKER, true));
				rabbit.addListener(new PackageDataReceiverListener(rabbit, DockerRabbitQueues.PACKAGE_REPLY.getQueue() + "_" + docker.getIdCard().getCluster().toLowerCase(), RabbitListenerType.SUBSCRIBER, false));
				rabbit.addListener(new PackageUpdateRequestListener(rabbit, DockerRabbitQueues.PACKAGE_UPDATEREQUEST.getQueue() + "_" + docker.getIdCard().getCluster().toLowerCase(), RabbitListenerType.MESSAGE_BROKER, false));

				matchmaking = new MatchmakingReplier();

				rabbit.addListener(new MatchmakingEnterRequestListener(rabbit, MatchmakingQueues.ENTER_REQUEST + "." + docker.getIdCard().getCluster(), RabbitListenerType.MESSAGE_BROKER, false));
			}

		};
	}

	public void fillCache() throws Exception
	{
		getData().setEntities(InstanceInfoCache.fetch());

		if (getData().getEntities() == null)
		{
			getData().setEntities(new HashMap<>());
		}

		for (Entry<String, List<InstanceEntity>> entry : getData().getEntities().entrySet())
		{
			String worldSystemName = entry.getKey();
			WorldSystem system = null;

			for (InstanceSystem instanceSystem : LocalDocker.getConfig().getSystems().values())
			{
				for (WorldSystem worldSystem : instanceSystem.getWorlds())
				{
					if (worldSystem.getName().equals(worldSystemName))
					{
						system = worldSystem;
					}
				}
			}

			for (InstanceEntity instanceEntity : entry.getValue())
			{
				instanceEntity.setSystem(system);
			}
		}
	}

	public void prepareClose()
	{
		Runtime.getRuntime().addShutdownHook(new Thread()
		{
			@Override
			public void run()
			{
				if (keepAliveTask != null)
				{
					keepAliveTask.cancel();
				}

				Docker docker = Docker.getInstance();
				RabbitPacketMessage rabbitPacketMessage = new RabbitPacketMessage(-1, docker.getIdCard().getFullId());
				RabbitPacket rabbitPacket = new RabbitPacket(rabbitPacketMessage, DockerRabbitQueues.SCLOSE.getQueue() 
						+ "_" + docker.getIdCard().getCluster(),
						false, RabbitPacketEncoder.UTF8, RabbitPacketType.PUBLISHER);
				docker.getRabbit().sendPacket(rabbitPacket);

				RabbitLogger.sendDockerLog(LogType.INFO, "Net docker closed.");
			}
		});
	}

	public void keepAlive(Docker docker)
	{
		this.keepAlive = new KeepAlive(docker);
		RabbitPacketMessage rabbitPacketMessage = new RabbitPacketMessage(-1, docker.getGsonExpose().toJson(keepAlive));
		RabbitPacket rabbitPacket = new RabbitPacket(rabbitPacketMessage, DockerRabbitQueues.KEEPALIVE.getQueue()
				+ "_" + docker.getIdCard().getCluster(),
				false, RabbitPacketEncoder.UTF8, RabbitPacketType.PUBLISHER);
		docker.getRabbit().sendPacket(rabbitPacket);
	}

}
