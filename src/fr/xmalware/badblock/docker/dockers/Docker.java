package fr.xmalware.badblock.docker.dockers;

import java.io.File;
import java.lang.reflect.Modifier;
import java.util.Timer;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import fr.badblock.api.common.minecraft.DockerRabbitQueues;
import fr.badblock.api.common.tech.mongodb.MongoConnector;
import fr.badblock.api.common.tech.mongodb.MongoService;
import fr.badblock.api.common.tech.rabbitmq.RabbitConnector;
import fr.badblock.api.common.tech.rabbitmq.RabbitService;
import fr.badblock.api.common.tech.rabbitmq.listener.RabbitListenerType;
import fr.badblock.api.common.tech.redis.RedisConnector;
import fr.badblock.api.common.tech.redis.RedisService;
import fr.badblock.api.common.utils.FileUtils;
import fr.badblock.api.common.utils.logs.Log;
import fr.badblock.api.common.utils.logs.LogType;
import fr.xmalware.badblock.docker.config.DockerConfiguration;
import fr.xmalware.badblock.docker.personaldata.IdCard;
import fr.xmalware.badblock.docker.rabbit.listeners.DockerCloseListener;
import fr.xmalware.badblock.docker.rabbit.listeners.DockerKeepAliveListener;
import fr.xmalware.badblock.docker.sharing.Sharing;
import lombok.Getter;

@Getter
public class Docker
{

	@Getter private static Docker					instance;

	private Gson								gson;
	private Gson								gsonExpose;
	private Gson								gsonAccur;
	private RabbitService				rabbit;
	private MongoService				mongo;
	private RedisService					redis;

	private IdCard 							idCard;

	private NetDocker					net;
	private Timer								timer;
	private DockerConfiguration	config;

	public Docker()
	{
		instance = this;
		timer = new Timer();
		gson = new Gson();
		gsonExpose = new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create();
		gsonAccur = new GsonBuilder().excludeFieldsWithoutExposeAnnotation().excludeFieldsWithModifiers(Modifier.TRANSIENT).create();

		try
		{
			this.loadConfiguration();
			this.loadRabbit();
			this.loadMongo();
			this.loadRedis();

			net = NetDocker.class.newInstance();
			LocalDocker.class.newInstance();
			
			new Sharing();
		}
		catch (Exception exception)
		{
			Log.log(LogType.WARNING, "Unable to load Docker.");
			exception.printStackTrace();
		}
	}

	private void loadConfiguration() throws Exception
	{
		File configurationFile = new File("config.json");
		String configurationData = FileUtils.readFile(configurationFile);
		this.config = getGson().fromJson(configurationData, DockerConfiguration.class);

		this.idCard = new IdCard(getConfig().getCluster(), getConfig().getId());
		System.out.println("user:" + config.getFtp().getUser() + " | " + config.getFtp().getPass());
	}

	private void loadRabbit() throws Exception
	{
		RabbitConnector rabbitConnector = RabbitConnector.getInstance();
		this.rabbit = rabbitConnector.registerService(new RabbitService("default", getConfig().getRabbit()));

		// Docker net
		rabbit.addListener(new DockerKeepAliveListener(rabbit, DockerRabbitQueues.KEEPALIVE.getQueue() + "_" + getIdCard().getCluster(), RabbitListenerType.SUBSCRIBER, false));
		rabbit.addListener(new DockerCloseListener(rabbit, DockerRabbitQueues.SCLOSE.getQueue() + "_" + getIdCard().getCluster(), RabbitListenerType.SUBSCRIBER, false));
	}
	
	private void loadRedis() throws Exception
	{
		RedisConnector redisConnector = RedisConnector.getInstance();
		this.redis = redisConnector.registerService(new RedisService("default", getConfig().getRedis()));
	}

	private void loadMongo() throws Exception
	{
		MongoConnector mongoConnector = MongoConnector.getInstance();
		this.mongo = mongoConnector.registerService(new MongoService("default", getConfig().getMongo()));
	}

}