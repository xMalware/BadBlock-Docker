package fr.xmalware.badblock.docker.sharing;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Queue;

import org.apache.commons.net.ftp.FTPClient;
import org.apache.commons.net.ftp.FTPSClient;

import com.google.common.collect.Queues;

import fr.badblock.api.common.minecraft.DockerRabbitQueues;
import fr.badblock.api.common.tech.rabbitmq.packet.RabbitPacket;
import fr.badblock.api.common.tech.rabbitmq.packet.RabbitPacketEncoder;
import fr.badblock.api.common.tech.rabbitmq.packet.RabbitPacketMessage;
import fr.badblock.api.common.tech.rabbitmq.packet.RabbitPacketType;
import fr.badblock.api.common.utils.logs.LogType;
import fr.xmalware.badblock.docker.config.DockerConfiguration;
import fr.xmalware.badblock.docker.config.FTPSettings;
import fr.xmalware.badblock.docker.dockers.Docker;
import fr.xmalware.badblock.docker.rabbit.RabbitLogger;
import fr.xmalware.badblock.docker.utils.DockerUtils;

public class Sharing {

	public static boolean ok = false;
	public static boolean updating = false;
	public static Map<String, Long> data;
	public static SimpleDateFormat dateFormat = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss");

	public Sharing()
	{
	}

	public static void ron(DockerConfiguration configuration) {
		RabbitLogger.sendDockerLog(LogType.INFO, "[SYNC] Updating the package, please wait..");

		updating = true;
		ok = false;
		data = null;

		RabbitPacketMessage rabbitMessage = new RabbitPacketMessage(-1, "-");
		RabbitPacket rabbitPacket = new RabbitPacket(rabbitMessage, DockerRabbitQueues.PACKAGE_REPLY.getQueue() + "_" + configuration.getCluster().toLowerCase(), false, 
				RabbitPacketEncoder.UTF8, RabbitPacketType.PUBLISHER);

		Docker.getInstance().getRabbit().sendPacket(rabbitPacket);

		while (!ok)
		{
			RabbitLogger.sendDockerLog(LogType.INFO, "[SYNC] Waiting for master reply..");
			try
			{
				Thread.sleep(1000);
			}
			catch (InterruptedException exception)
			{
				exception.printStackTrace();
			}
		}

		Sharing.run(configuration, data, false);
		updating = false;
	}

	public static void run(DockerConfiguration configuration, Map<String, Long> data, boolean thread) {
		Runnable runnable = new Runnable()
		{
			@Override
			public void run()
			{
				RabbitLogger.sendDockerLog(LogType.INFO, "[UPDATE] Looking for local docker package state...");

				File packageFolder = new File("package/");
				File logFolder = new File(packageFolder, "logs/");

				Map<String, Long> compared = DockerUtils.getFileTimestamps(packageFolder.getAbsolutePath(), logFolder.getAbsolutePath());

				RabbitLogger.sendDockerLog(LogType.INFO, "[UPDATE] Comparing files between remote server and this node...");

				List<File> filesToFetch = new ArrayList<>();
				List<File> filesToDelete = new ArrayList<>();

				for (Entry<String, Long> comparerEntry : data.entrySet())
				{
					if (comparerEntry.getKey().startsWith("logs/"))
					{
						continue;
					}

					if (!compared.containsKey(comparerEntry.getKey()))
					{
						filesToFetch.add(new File(packageFolder, comparerEntry.getKey()));
					}
					else if (compared.get(comparerEntry.getKey()).longValue() != comparerEntry.getValue().longValue())
					{
						filesToFetch.add(new File(packageFolder, comparerEntry.getKey()));
					}
				}

				for (Entry<String, Long> comparedEntry : compared.entrySet())
				{
					if (comparedEntry.getKey().startsWith("logs/"))
					{
						continue;
					}

					if (!data.containsKey(comparedEntry.getKey()))
					{
						filesToDelete.add(new File(packageFolder, comparedEntry.getKey()));
					}
				}

				RabbitLogger.sendDockerLog(LogType.INFO, "[UPDATE] Comparison ended. (" + filesToFetch.size() + " different files found)");

				// System.setProperty("javax.net.debug", "ssl");
				FTPSettings ftp = configuration.getFtp();

				String server = ftp.getServer();
				int port = ftp.getPort();
				String user = ftp.getUser();
				String pass = ftp.getPass();
				String locate = ftp.getLocate();
				String pack = ftp.getPack();

				FTPClient ftpClient = getFtpClient(server, port, user, pass);
				try
				{
					listDirectory(server, port, user, pass, locate, pack, filesToFetch, filesToDelete);
					ftpClient.disconnect();

					RabbitLogger.sendDockerLog(LogType.SUCCESS, "[UPDATE] Package folder synchronized successfully.");
				}
				catch (Exception ex)
				{
					RabbitLogger.sendDockerLog(LogType.ERROR, "[UPDATE] Something gone wrong: " + ex.getMessage());
					ex.printStackTrace();
				}
				finally
				{
					try
					{
						if (ftpClient.isConnected())
						{
							ftpClient.logout();
							ftpClient.disconnect();
						}
					}
					catch (IOException ex)
					{
						ex.printStackTrace();
					}
				}

			}
		};

		if (thread)
		{
			new Thread("update_worker")
			{
				@Override
				public void run()
				{
					runnable.run();
				}
			}.start();
		}
		else
		{
			runnable.run();
		}
	}

	static void listDirectory(String host, int port, String user, String pass, String ftpLocation, String pack, List<File> files, List<File> filesToDelete) throws IOException
	{
		int threadsNumber = (files.size() / 16) + 1;

		RabbitLogger.sendDockerLog(LogType.INFO, "[UPDATE] Deleting files... (with " + threadsNumber + " thread" + (threadsNumber == 0 || threadsNumber > 1 ? "s" : "") + ")");

		filesToDelete.forEach(file -> file.delete());

		RabbitLogger.sendDockerLog(LogType.INFO, "[UPDATE] Fetching files... (with " + threadsNumber + " thread" + (threadsNumber == 0 || threadsNumber > 1 ? "s" : "") + ")");

		List<SharingThread> threads = new ArrayList<>();
		Queue<File> queue = Queues.newConcurrentLinkedQueue(files);

		for (int i = 0; i < threadsNumber; i++)
		{
			SharingThread thread = new SharingThread("dockerFetch/" + i)
			{
				@Override
				public void run()
				{
					FTPClient ftpClient = getFtpClient(host, port, user, pass);

					while (!queue.isEmpty())
					{
						File localFile = queue.poll();
						if (localFile == null)
						{
							try
							{
								ftpClient.disconnect();
							}
							catch (IOException e)
							{
								e.printStackTrace();
							}

							this.setFinishedDownload(true);
							break;
						}

						currentFile = localFile.getAbsolutePath();

						try
						{
							if (!localFile.exists())
							{
								try
								{
									File fo = new File(localFile.getParentFile() + "/");

									if (!fo.exists())
									{
										fo.mkdirs();
										fo.mkdir();
									}

									localFile.createNewFile();

									OutputStream outputStream1 = new BufferedOutputStream(new FileOutputStream(localFile));
									boolean success = ftpClient.retrieveFile(ftpLocation + "/" + localFile.getAbsolutePath().replaceAll(pack, ""), outputStream1);
									outputStream1.close();

									Calendar calendar = Calendar.getInstance();
									calendar.setTime(new Date());

									if (success)
									{
										localFile.setLastModified(data.get(localFile.getAbsolutePath().replaceAll(pack, "")));
										RabbitLogger.sendDockerLog(LogType.SUCCESS, "[UPDATE] Created file " + 
												localFile.getAbsolutePath().replaceAll(pack, "") + " (" + localFile.length() + " bytes)");
									} 
									else
									{
										RabbitLogger.sendDockerLog(LogType.ERROR, "[UPDATE] Error while creating file (" +
												localFile.getAbsolutePath().replaceAll(pack, "") + " | " + ftpClient.getReplyCode() + " [" + ftpClient.getReplyString() + "]).");
									}

								}
								catch (Exception error) 
								{
									error.printStackTrace();
								}	
							}
							else
							{
								Calendar calendar = Calendar.getInstance();
								calendar.setTime(new Date());

								localFile.delete();
								localFile.createNewFile();

								OutputStream outputStream1 = new BufferedOutputStream(new FileOutputStream(localFile));
								boolean success = ftpClient.retrieveFile(ftpLocation + "/" + localFile.getAbsolutePath().replaceAll(pack, ""), outputStream1);
								outputStream1.close();

								if (success)
								{
									localFile.setLastModified(data.get(localFile.getAbsolutePath().replaceAll(pack, "")));
									RabbitLogger.sendDockerLog(LogType.SUCCESS, "[UPDATE] Edited file " + 
											localFile.getAbsolutePath().replaceAll(pack, "") + " (" + localFile.length() + " bytes)");
								}
								else
								{
									RabbitLogger.sendDockerLog(LogType.ERROR, "[UPDATE] Error while editing file (" + 
											localFile.getAbsolutePath().replaceAll(pack, "") + " | " + ftpClient.getReplyCode() + " [" +
											ftpClient.getReplyString() + "]).");
								}
							}
						}
						catch(Exception error)
						{
							error.printStackTrace();
						}
					}
					
					try
					{
						ftpClient.disconnect();
					}
					catch (IOException e)
					{
						e.printStackTrace();
					}
					
					this.setFinishedDownload(true);
				}
			};
			
			thread.start();
			threads.add(thread);
			
			try
			{
				Thread.sleep(50);
			}
			catch (InterruptedException e)
			{
				e.printStackTrace();
			}
		}
		
		while (threads.parallelStream().filter(thread -> !thread.isFinishedDownload() && thread.isAlive()).count() > 0)
		{
			try
			{
				Thread.sleep(1000);
			}
			catch (InterruptedException e)
			{
				e.printStackTrace();
			}
		}
		
		System.gc();
	}

	private static FTPClient getFtpClient(String server, int port, String user, String pass)
	{
		FTPClient ftpClient = new FTPClient();
		
		try
		{
			//ftpClient.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out), true));
			ftpClient.connect(server, port);
			//ftpClient.execPBSZ(0);
			//ftpClient.execPROT("P");
			ftpClient.setBufferSize(0);
			ftpClient.login(user, pass);
			ftpClient.setFileType(2);
			ftpClient.setAutodetectUTF8(true);
			ftpClient.setListHiddenFiles(true);
			ftpClient.enterLocalActiveMode();
		}
		catch(Exception error)
		{
			error.printStackTrace();
		}
		
		return ftpClient;
	}

	public static ArrayList<File> listf(String directoryName)
	{
		File directory = new File(directoryName);
		ArrayList<File> files = new ArrayList<>();
		
		// get all the files from a directory
		File[] fList = directory.listFiles();
		
		for (File file : fList)
		{
			if (file.isFile())
			{
				files.add(file);
			}
			else if (file.isDirectory())
			{
				files.addAll(listf(file.getAbsolutePath()));
			}
		}
		
		return files;
	}

}